import debug from 'debug';

import MakeWorkerSource from '../libs/workerSource.maker.js';

const log = debug('process:log');
// Disable logging in production
if (ENV !== 'production') {
  debug.enable('*');
} else {
  debug.disable();
}

export default class Process {
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
    this.queue = [];
    log('run Process class');
    this.dispatcher.on('create:new:process', this.newProcess, this);
  }

  create(processBody, options) {
    return this.runWorker(processBody, options, true);
  }

  newProcess(processBody, options) {
    this.runWorker(processBody, options);
  }

  runWorker(processBody, options, promisify) {
    let worker;
    if (!processBody || (processBody && !processBody.fn)) {
      throw new Error(
      `
        With 'create:new:process' event you should send processBody
        ex.
        ...dispatcher.emit(
            'create:new:process', // or webOs.process.create(...);
            {
              deps: Array ::: (optional) ::: In this case you should write all dependency paths,
              fn: Function ::: (requires) ::: It is this function witch will run in new process          
            },
            {
              onmessage: Function ::: (optional) ::: It is worker onmessage callback,
              onerror: Function ::: (optional) ::: it is worker onerror callback,
              terminate: Boolean ::: (optional) ::: default => false ::: If this flag is true and
                                                    you have onmessage then after process job it will
                                                    be terminated, but when you havn't onmessage and want
                                                    terminate process you can kill it yourself in fn
                                                    callback :)
            }
          )
      `);
    } else if (typeof processBody.fn !== 'function') {
      throw new Error(`'fn' in new process should be Function`);
    } else if (processBody.deps && !Array.isArray(processBody.deps)) {
      throw new Error(`'deps' in new process should be Array`);
    } else {
      let workerSource = new MakeWorkerSource(processBody).workerSource();

      let code = workerSource.toString();

      code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));

      let blob = new Blob([code], {type: 'application/javascript'});
      worker = new Worker(URL.createObjectURL(blob));
      // create in processes queue
      this.queue.push(worker);

      if (options.onmessage) {
        if (typeof options.onmessage === 'function') {
          if (options.terminate) {
            if (typeof options.terminate === 'boolean') {
              worker.onmessage = function() {
                options.onmessage.apply(this, arguments);
                worker.terminate();
              };
            } else {
              throw new Error(`'terminate' in new process should be Boolean`);
            }
          } else {
            worker.onmessage = options.onmessage;
          }
        } else {
          throw new Error(`'onmessage' in new process should be Function`);
        }
      }

      if (options.onerror) {
        if (typeof options.onerror === 'function') {
          worker.onerror = options.onerror;
        } else {
          throw new Error(`'onerror' in new process should be Function`);
        }
      }
    }

    if (promisify && worker) {
      return worker;
    }
  }
}