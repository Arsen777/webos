/**
 * The process for webos.
 * @module core/process
 */
import debug from 'debug';

import MakeWorkerSource from '../libs/workerSource.maker.js';

const log = debug('process:log');
// Disable logging in production
if (ENV !== 'production') {
  debug.enable('*');
} else {
  debug.disable();
}

/** Class representing a process for webos.
 *  @extends EventEmmiter3
 */

export default class Process {
  /**
   * Create a dispatcher, processes and _installListeners.
   * @param { Dispatcher } dispatcher - The main dispatcher.
   */
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
    this.processes = [];
    log('run Process class');
    this._installListeners();
  }

  /**
   * Set the listeners.
   */

  _installListeners() {
    this.dispatcher.on('create:new:process', this.newProcess, this);
  }

  /**
   * Method for create new process in webos.
   * @param { object } processBody - Process body can contain process dependencies and fn
   * @param { object } options - options can contain onmessage and onerror callbacks and terminate flag
   * @return { worker object } worker - return 'runWorker' method with 'processBody, options, true'
   * The 3th param in 'runWorker' method is promisify flag. Different between with 'create' and 'newProcess'
   * is theirs returned value. NOTEÖ‰ 'newProcess' method nothing returned. 
   */

  create(processBody, options) {
    return this.runWorker(processBody, options, true);
  }

  /**
   * Method for create new process in webos.
   * @param { object } processBody - Process body can contain process dependencies and fn
   * @param { object } options - options can contain onmessage and onerror callbacks and terminate flag
   */

  newProcess(processBody, options) {
    this.runWorker(processBody, options);
  }

  /**
   * Method for create new process in webos.
   * @param { object } processBody - Process body can contain process dependencies and fn
   * @param { object } options - options can contain onmessage and onerror callbacks and terminate flag
   */

  runWorker(processBody, options, promisify) {
    let worker;
    if (!processBody || (processBody && !processBody.fn)) {
      throw new Error(
      `
        With 'create:new:process' event you should send processBody
        ex.
        ...dispatcher.emit(
            'create:new:process', // or webOs.process.create(...);
            {
              deps: Array ::: (optional) ::: In this case you should write all dependency paths,
              fn: Function ::: (requires) ::: It is this function witch will run in new process          
            },
            {
              onmessage: Function ::: (optional) ::: It is worker onmessage callback,
              onerror: Function ::: (optional) ::: it is worker onerror callback,
              terminate: Boolean ::: (optional) ::: default => false ::: If this flag is true and
                                                    you have onmessage then after process job it will
                                                    be terminated, but when you havn't onmessage and want
                                                    terminate process you can kill it yourself in fn
                                                    callback :)
            }
          )
      `);
    } else if (typeof processBody.fn !== 'function') {
      throw new Error(`'fn' in new process should be Function`);
    } else if (processBody.deps && !Array.isArray(processBody.deps)) {
      throw new Error(`'deps' in new process should be Array`);
    } else {
      let workerSource = new MakeWorkerSource(processBody).workerSource();

      let code = workerSource.toString();

      code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));

      let blob = new Blob([code], {type: 'application/javascript'});
      worker = new Worker(URL.createObjectURL(blob));
      // create in processes
      this.processes.push(worker);

      if (options.onmessage) {
        if (typeof options.onmessage === 'function') {
          if (options.terminate) {
            if (typeof options.terminate === 'boolean') {
              worker.onmessage = function() {
                options.onmessage.apply(this, arguments);
                worker.terminate();
              };
            } else {
              throw new Error(`'terminate' in new process should be Boolean`);
            }
          } else {
            worker.onmessage = options.onmessage;
          }
        } else {
          throw new Error(`'onmessage' in new process should be Function`);
        }
      }

      if (options.onerror) {
        if (typeof options.onerror === 'function') {
          worker.onerror = options.onerror;
        } else {
          throw new Error(`'onerror' in new process should be Function`);
        }
      }
    }

    if (promisify && worker) {
      return worker;
    }
  }
}